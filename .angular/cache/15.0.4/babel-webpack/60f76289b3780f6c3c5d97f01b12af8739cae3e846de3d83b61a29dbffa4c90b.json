{"ast":null,"code":"import { EventEmitter, Component, ChangeDetectorRef, Input, Output, Directive, ElementRef, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { SVG } from '@svgdotjs/svg.js';\n\n/**\n * Import Angular libraries.\n */\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nfunction SvgContainerComponent_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r2 = ɵngcc0.ɵɵgetCurrentView();\n    ɵngcc0.ɵɵelementStart(0, \"div\", 2);\n    ɵngcc0.ɵɵlistener(\"dblclick\", function SvgContainerComponent_div_1_Template_div_dblclick_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r2);\n      const ctx_r1 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r1.onPointDoubleClick());\n    })(\"click\", function SvgContainerComponent_div_1_Template_div_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r2);\n      const ctx_r3 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r3.onPointClick());\n    })(\"mousemove\", function SvgContainerComponent_div_1_Template_div_mousemove_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r2);\n      const ctx_r4 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r4.onPointHover());\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵstyleProp(\"width\", ctx_r0.pointSize, \"px\")(\"height\", ctx_r0.pointSize, \"px\")(\"left\", ctx_r0.pointXCoordinate, \"px\")(\"top\", ctx_r0.pointYCoordinate, \"px\");\n  }\n}\nconst _c0 = [\"*\"];\nlet SvgContainerComponent = /*#__PURE__*/(() => {\n  class SvgContainerComponent {\n    /**\n     * Create SVG Container component instance.\n     * @param cdRef - Change Detector Ref object instance.\n     */\n    constructor(cdRef) {\n      this.cdRef = cdRef;\n      this.mouseInContainer = false;\n      this._triggerCoordinateChange = false;\n      this.height = 200; // Height of the container.\n      this.showGrid = false; // Indicator if grid image should be shown in the background of svg container.\n      this.grid = {\n        width: 10,\n        height: 10,\n        strokeColor: 'black'\n      }; // Grid object based on which the grid for the svg will be constructed\n      this.hoverable = false; // Indicator if user should be able to see dot on hover, to capture coordinates.\n      this.pointSize = 10; // Numeric value in pixels, to indicate how large should the point be.\n      this.viewBox = []; // Viewbox of the container, must be an array consisting of 4 integers [x, y, width, height].\n      /**\n       * Output variables used within the component.\n       */\n      this.clickEvent = new EventEmitter(); // Event handler for retrieving coordinates at clicked position\n      this.doubleClickEvent = new EventEmitter(); // Event handler for retrieving coordinates at position where you double-click.\n      this.mouseOverEvent = new EventEmitter(); // Event handler when mouse is moved over the container.\n      this.mouseOutEvent = new EventEmitter(); // Event handler when the mouse exits the container.\n      this.mouseMoveEvent = new EventEmitter();\n      // Event handler when the mouse is being moved on the container.\n      this.onInitialize = new EventEmitter();\n    }\n    /**\n     * Does all required pre-requisites when input variables changes.\n     * @param changes - Changes object containing input variable changes for the container.\n     */\n    ngOnChanges(changes) {\n      // Check if svg container is defined\n      if (this._svg) {\n        // Check if viewbox has changed\n        if (changes.viewBox && changes.viewBox.currentValue !== changes.viewBox.previousValue) {\n          // Let's update viewbox value\n          this.viewBox = changes.viewBox.currentValue;\n          // Let's update viewbox\n          this.updateViewbox();\n        }\n        // Let's update the height\n        if (changes.height && changes.height.currentValue !== changes.height.previousValue) {\n          // Update height\n          this.height = changes.height.currentValue;\n          // Update height of the svg container\n          this._svg.size('100%', this.height);\n        }\n        // Let's update pattern in case grid was changed\n        if (changes.showGrid || changes.grid) {\n          // Update values\n          this.grid = changes.grid ? changes.grid.currentValue : this.grid;\n          this.showGrid = changes.showGrid ? changes.showGrid.currentValue : this.showGrid;\n          // Let's update the pattern\n          this.setGridPattern();\n        }\n        // Check if any other input variables have changed\n        if (changes.hoverable && changes.hoverable.currentValue !== changes.hoverable.previousValue || changes.pointSize && changes.pointSize.currentValue !== changes.pointSize.previousValue) {\n          // Update values\n          this.hoverable = changes.hoverable ? changes.hoverable.currentValue : this.hoverable;\n          this.pointSize = changes.pointSize ? changes.pointSize.currentValue : this.pointSize;\n          // Let's refresh the view\n          this.cdRef.detectChanges();\n        }\n      }\n    }\n    /**\n     * Does all required pre-requisites before initializing the component.\n     */\n    ngAfterViewInit() {\n      this.setContainer(this.containerId);\n    }\n    /**\n     * Retrieves container instance.\n     * @returns SVG Container instance.\n     */\n    getContainer() {\n      return this._svg;\n    }\n    /**\n     * Does all required pre-requisites and adjusts hoverable point position.\n     * @param event - Mouse event handler from the DOM.\n     */\n    adjustPointPosition(event) {\n      // Return if we don't have hoverable enabled\n      if (!this.hoverable) {\n        return;\n      }\n      // Set correct point coordinates\n      if (this._triggerCoordinateChange) {\n        this.pointXCoordinate = event.offsetX - this.pointSize / 2;\n        this.pointYCoordinate = event.offsetY - this.pointSize / 2;\n      }\n      // Trigger coordinate change\n      this._triggerCoordinateChange = true;\n    }\n    /**\n     * Adjust the mouse move position, and sends out to the user.\n     * @param event - Mouse event handler from the DOM.\n     */\n    adjustMouseMovePosition(event) {\n      if (this.hoverable && this._triggerCoordinateChange) {\n        this.mouseMoveEvent.emit({\n          x: this.pointXCoordinate + this.pointSize / 2,\n          y: this.pointYCoordinate + this.pointSize / 2\n        });\n      } else if (!this.hoverable) {\n        this.mouseMoveEvent.emit({\n          x: event.offsetX,\n          y: event.offsetY\n        });\n      }\n    }\n    /**\n     * Does all required pre-requisites when hovered point is clicked.\n     */\n    onPointClick() {\n      // Indicate that single click has happened.\n      this._singleClickHappened = true;\n      // Assign coordinates\n      const x = this.pointXCoordinate + this.pointSize / 2;\n      const y = this.pointYCoordinate + this.pointSize / 2;\n      // Set timeout, to make sure we cancel it if double-click happens.\n      setTimeout(() => {\n        if (this._singleClickHappened) {\n          this.clickEvent.emit({\n            x,\n            y\n          });\n        }\n      }, 250);\n    }\n    /**\n     * Does all required pre-requisites when hovered point is double clicked.\n     */\n    onPointDoubleClick() {\n      // Let's fire double click event\n      this.doubleClickEvent.emit({\n        x: this.pointXCoordinate + this.pointSize / 2,\n        y: this.pointYCoordinate + this.pointSize / 2\n      });\n      // Let's set that double click has happened\n      this._singleClickHappened = false;\n    }\n    /**\n     * Make sure that we don't trigger coordinate change, if we hover point.\n     */\n    onPointHover() {\n      this._triggerCoordinateChange = false;\n    }\n    /**\n     * Does all required pre-requisites and updates the viewbox of the svg container.\n     */\n    updateViewbox() {\n      // Check if we are still using viewbox\n      if (this.viewBox.length === 4) {\n        // Set viewbox\n        this._svg.viewbox(this.viewBox[0], this.viewBox[1], this.viewBox[2], this.viewBox[3]);\n      } else {\n        // Remove viewbox\n        this._svg.viewbox();\n      }\n    }\n    /**\n     * Sets a container instance.\n     * @param id - ID of the container.\n     */\n    setContainer(id) {\n      // Assign viewbox only if it's defined\n      if (this.viewBox && this.viewBox.length === 4) {\n        this._svg = SVG().addTo(`#${id}`).size('100%', this.height).viewbox(this.viewBox[0], this.viewBox[1], this.viewBox[2], this.viewBox[3]);\n      } else {\n        this._svg = SVG().addTo(`#${id}`).size('100%', this.height);\n      }\n      // Let's set pattern if grid and showGrid is set\n      if (this.showGrid) {\n        this.setGridPattern();\n      }\n      // Let's output the svg container element\n      this.onInitialize.emit(this._svg);\n    }\n    /**\n     * Does all required pre-requisites and initializes or updates grid pattern.\n     */\n    setGridPattern() {\n      // Let's remove old pattern if we have created one\n      if (this._pattern) {\n        this._pattern.remove();\n      }\n      // Let's remove old grid if we have created one\n      if (this._grid) {\n        this._grid.remove();\n      }\n      // Let's check if we want to show grid\n      if (this.showGrid) {\n        // Let's create the pattern\n        this._pattern = this._svg.pattern(this.grid.width, this.grid.height, addedPattern => {\n          addedPattern.rect(this.grid.width, this.grid.height).fill('transparent').stroke(this.grid.strokeColor);\n        });\n        // Let's create grid\n        this._grid = this._svg.rect().size('100%', '100%').fill(this._pattern);\n      }\n    }\n  }\n  SvgContainerComponent.ɵfac = function SvgContainerComponent_Factory(t) {\n    return new (t || SvgContainerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n  SvgContainerComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: SvgContainerComponent,\n    selectors: [[\"svg-container\"]],\n    inputs: {\n      height: \"height\",\n      showGrid: \"showGrid\",\n      grid: \"grid\",\n      hoverable: \"hoverable\",\n      pointSize: \"pointSize\",\n      viewBox: \"viewBox\",\n      containerId: \"containerId\"\n    },\n    outputs: {\n      clickEvent: \"clickEvent\",\n      doubleClickEvent: \"doubleClickEvent\",\n      mouseOverEvent: \"mouseOverEvent\",\n      mouseOutEvent: \"mouseOutEvent\",\n      mouseMoveEvent: \"mouseMoveEvent\",\n      onInitialize: \"onInitialize\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c0,\n    decls: 3,\n    vars: 2,\n    consts: [[1, \"svg-container\", 3, \"id\", \"mousemove\", \"mouseenter\", \"mouseleave\"], [\"class\", \"svg-hover-point\", 3, \"width\", \"height\", \"left\", \"top\", \"dblclick\", \"click\", \"mousemove\", 4, \"ngIf\"], [1, \"svg-hover-point\", 3, \"dblclick\", \"click\", \"mousemove\"]],\n    template: function SvgContainerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵlistener(\"mousemove\", function SvgContainerComponent_Template_div_mousemove_0_listener($event) {\n          ctx.mouseInContainer = true;\n          ctx.adjustPointPosition($event);\n          return ctx.adjustMouseMovePosition($event);\n        })(\"mouseenter\", function SvgContainerComponent_Template_div_mouseenter_0_listener($event) {\n          ctx.mouseInContainer = true;\n          return ctx.mouseOverEvent.emit($event);\n        })(\"mouseleave\", function SvgContainerComponent_Template_div_mouseleave_0_listener($event) {\n          ctx.mouseInContainer = false;\n          return ctx.mouseOutEvent.emit($event);\n        });\n        ɵngcc0.ɵɵtemplate(1, SvgContainerComponent_div_1_Template, 1, 8, \"div\", 1);\n        ɵngcc0.ɵɵprojection(2);\n        ɵngcc0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"id\", ctx.containerId);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.hoverable && ctx.mouseInContainer);\n      }\n    },\n    dependencies: [ɵngcc1.NgIf],\n    styles: [\".svg-hover-point[_ngcontent-%COMP%]{background-color:#000;border:1px solid #fff;border-radius:50%;position:absolute}.svg-container[_ngcontent-%COMP%]{position:relative}\"]\n  });\n  return SvgContainerComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Import Angular libraries.\n */\nlet SvgRectDirective = /*#__PURE__*/(() => {\n  class SvgRectDirective {\n    /**\n     * Create SVG Rect directive.\n     * @param _svgContainer - Host SVG Container Component object instance.\n     * @param _elRef - Angular element reference object instance.\n     */\n    constructor(_svgContainer, _elRef) {\n      this._svgContainer = _svgContainer;\n      this._elRef = _elRef;\n      this.color = '#000'; // Color of the rectangular background\n      this.x = 0; // Starting point on x axis.\n      this.y = 0; // Starting point on y axis.\n      this.rx = 0; // Radius for x axis.\n      this.ry = 0; // Radius for y axis.\n      this.classes = []; // List of CSS classes which needs to be added.\n      /**\n       * Output variables for the rectangular directive.\n       */\n      this.clickEvent = new EventEmitter();\n      this.doubleClickEvent = new EventEmitter();\n      this.mouseOverEvent = new EventEmitter();\n      this.mouseOutEvent = new EventEmitter();\n      this.onInitialize = new EventEmitter();\n    }\n    /**\n     * Creates or updates the rectangular object within the container\n     */\n    ngAfterViewChecked() {\n      // Check if container is created and no rectangular object is created\n      if (this._svgContainer.getContainer() && !this._rect) {\n        this.createRect();\n      }\n    }\n    /**\n     * Does all required pre-requisites before destroying the component.\n     */\n    ngOnDestroy() {\n      this._rect.remove();\n    }\n    /**\n     * Is called when changes are made to the rect object.\n     * @param changes - Angular Simple Changes object containing all of the changes.\n     */\n    ngOnChanges(changes) {\n      if (this._rect) {\n        // If we have already created the object, update it.\n        this.updateRect();\n        // Check if classes were changed\n        if (changes.classes && changes.classes.currentValue !== changes.classes.previousValue) {\n          // Get classes that needs to be removed\n          const classesToRemove = changes.classes.previousValue.filter(previousClass => !changes.classes.currentValue.some(currentClass => currentClass === previousClass));\n          // Get classes that needs to be added\n          const classesToAdd = changes.classes.currentValue.filter(currentClass => !changes.classes.previousValue.some(previousClass => currentClass === previousClass));\n          // Add and remove classes\n          this.addRemoveClasses(classesToAdd, classesToRemove);\n        }\n      }\n    }\n    /**\n     * Update rectangular object within the SVG container.\n     */\n    updateRect() {\n      this._rect.size(this.width, this.height) // Update the width and height\n      .fill(this.color) // Update the color\n      .radius(this.rx, this.ry) // Update the radius\n      .move(this.x, this.y); // Update the coordinates\n      // Let's set element in a correct position\n      this.setCorrectPosition();\n    }\n    /**\n     * Create rectangular object within the SVG container.\n     */\n    createRect() {\n      this._rect = this._svgContainer.getContainer().rect(this.width, this.height) // Set height and width of the rect\n      .fill(this.color) // Set fill color\n      .move(this.x, this.y) // Set coordinates\n      .radius(this.rx, this.ry) // Set radius\n      .on('click', evt => this.clickEvent.emit(evt)) // Assign click event\n      .on('dblclick', evt => this.doubleClickEvent.emit(evt)) // Assign double click event\n      .on('mouseover', evt => this.mouseOverEvent.emit(evt)) // Assign mouse over event\n      .on('mouseout', evt => this.mouseOutEvent.emit(evt)); // Assign mouse out event\n      // Let's set element in a correct position\n      this.setCorrectPosition();\n      // Add classes to the rect\n      this.addRemoveClasses(this.classes);\n      // Let's output the rect element\n      this.onInitialize.emit(this._rect);\n    }\n    /**\n     * Sets correct position for the element.\n     */\n    setCorrectPosition() {\n      // Find position of an element within the parent container\n      const position = Array.prototype.slice.call(this._elRef.nativeElement.parentElement.children).indexOf(this._elRef.nativeElement);\n      // Let's update and insert element in a correct position.\n      if (this._svgContainer.getContainer().get(position) && this._rect.position() !== position) {\n        this._rect.insertBefore(this._svgContainer.getContainer().get(position));\n      }\n    }\n    /**\n     * Adds classes to the rect object.\n     * @param classesToAdd - List of classes, which needs to be added.\n     * @param classesToRemove - List of classes, which needs to be removed.\n     */\n    addRemoveClasses(classesToAdd, classesToRemove = []) {\n      // First let's remove classes, that are not necessary anymore\n      for (const classToRemove of classesToRemove) {\n        this._rect.removeClass(classToRemove);\n      }\n      // Now let's add new classes\n      for (const classToAdd of classesToAdd) {\n        this._rect.addClass(classToAdd);\n      }\n    }\n  }\n  SvgRectDirective.ɵfac = function SvgRectDirective_Factory(t) {\n    return new (t || SvgRectDirective)(ɵngcc0.ɵɵdirectiveInject(SvgContainerComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n  SvgRectDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: SvgRectDirective,\n    selectors: [[\"svg-rect\"]],\n    inputs: {\n      color: \"color\",\n      x: \"x\",\n      y: \"y\",\n      rx: \"rx\",\n      ry: \"ry\",\n      classes: \"classes\",\n      height: \"height\",\n      width: \"width\"\n    },\n    outputs: {\n      clickEvent: \"clickEvent\",\n      doubleClickEvent: \"doubleClickEvent\",\n      mouseOverEvent: \"mouseOverEvent\",\n      mouseOutEvent: \"mouseOutEvent\",\n      onInitialize: \"onInitialize\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return SvgRectDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Import Angular libraries.\n */\nlet SvgCircleDirective = /*#__PURE__*/(() => {\n  class SvgCircleDirective {\n    /**\n     * Create SVG Circle directive.\n     * @param _svgContainer - Host SVG Container Component object instance.\n     * @param _elRef - Angular element reference object instance.\n     */\n    constructor(_svgContainer, _elRef) {\n      this._svgContainer = _svgContainer;\n      this._elRef = _elRef;\n      this.color = '#000'; // Color of the circle background\n      this.x = 0; // Starting point on x axis.\n      this.y = 0; // Starting point on y axis.\n      this.classes = []; // List of CSS classes which needs to be added.\n      /**\n       * Output variables for the circle directive.\n       */\n      this.clickEvent = new EventEmitter();\n      this.doubleClickEvent = new EventEmitter();\n      this.mouseOverEvent = new EventEmitter();\n      this.mouseOutEvent = new EventEmitter();\n      this.onInitialize = new EventEmitter();\n    }\n    /**\n     * Creates the circle object within the container.\n     */\n    ngAfterViewChecked() {\n      // Check if container is created and no circle object is created\n      if (this._svgContainer.getContainer() && !this._circle) {\n        // If so, let's create a circle\n        this.createCircle();\n      }\n    }\n    /**\n     * Does all required pre-requisites before destroying the component.\n     */\n    ngOnDestroy() {\n      this._circle.remove();\n    }\n    /**\n     * Is called when changes are made to the circle object.\n     * @param changes - Angular Simple Changes object containing all of the changes.\n     */\n    ngOnChanges(changes) {\n      if (this._circle) {\n        // If we have already created the object, update it.\n        this.updateCircle();\n        // Check if classes were changed\n        if (changes.classes && changes.classes.currentValue !== changes.classes.previousValue) {\n          // Get classes that needs to be removed\n          const classesToRemove = changes.classes.previousValue.filter(previousClass => !changes.classes.currentValue.some(currentClass => currentClass === previousClass));\n          // Get classes that needs to be added\n          const classesToAdd = changes.classes.currentValue.filter(currentClass => !changes.classes.previousValue.some(previousClass => currentClass === previousClass));\n          // Add and remove classes\n          this.addRemoveClasses(classesToAdd, classesToRemove);\n        }\n      }\n    }\n    /**\n     * Update circle object within the SVG container.\n     */\n    updateCircle() {\n      this._circle.size(this.diameter) // Set the diameter (twice the radius)\n      .fill(this.color) // Set the fill color\n      .attr('cx', +this.x + +this.diameter / 2) // Set x position\n      .attr('cy', +this.y + +this.diameter / 2); // Set y position\n      // Let's set element in a correct position\n      this.setCorrectPosition();\n    }\n    /**\n     * Create circle object within the SVG container.\n     */\n    createCircle() {\n      this._circle = this._svgContainer.getContainer().circle(this.diameter) // Create the circle with diameter (twice the radius)\n      .fill(this.color) // Set the fill color\n      .attr('cx', +this.x + +this.diameter / 2) // Set x position\n      .attr('cy', +this.y + +this.diameter / 2) // Set y position\n      .on('click', evt => this.clickEvent.emit(evt)) // Assign click event\n      .on('dblclick', evt => this.doubleClickEvent.emit(evt)) // Assign double click event\n      .on('mouseover', evt => this.mouseOverEvent.emit(evt)) // Assign mouse over event\n      .on('mouseout', evt => this.mouseOutEvent.emit(evt)); // Assign mouse out event\n      // Let's set element in a correct position\n      this.setCorrectPosition();\n      // Add classes to the circle\n      this.addRemoveClasses(this.classes);\n      // Let's output the circle element\n      this.onInitialize.emit(this._circle);\n    }\n    /**\n     * Sets correct position for the element.\n     */\n    setCorrectPosition() {\n      // Find position of an element within the parent container\n      const position = Array.prototype.slice.call(this._elRef.nativeElement.parentElement.children).indexOf(this._elRef.nativeElement);\n      // Let's update and insert element in a correct position.\n      if (this._svgContainer.getContainer().get(position) && this._circle.position() !== position) {\n        this._circle.insertBefore(this._svgContainer.getContainer().get(position));\n      }\n    }\n    /**\n     * Adds classes to the circle object.\n     * @param classesToAdd - List of classes, which needs to be added.\n     * @param classesToRemove - List of classes, which needs to be removed.\n     */\n    addRemoveClasses(classesToAdd, classesToRemove = []) {\n      // First let's remove classes, that are not necessary anymore\n      for (const classToRemove of classesToRemove) {\n        this._circle.removeClass(classToRemove);\n      }\n      // Now let's add new classes\n      for (const classToAdd of classesToAdd) {\n        this._circle.addClass(classToAdd);\n      }\n    }\n  }\n  SvgCircleDirective.ɵfac = function SvgCircleDirective_Factory(t) {\n    return new (t || SvgCircleDirective)(ɵngcc0.ɵɵdirectiveInject(SvgContainerComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n  SvgCircleDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: SvgCircleDirective,\n    selectors: [[\"svg-circle\"]],\n    inputs: {\n      color: \"color\",\n      x: \"x\",\n      y: \"y\",\n      classes: \"classes\",\n      diameter: \"diameter\"\n    },\n    outputs: {\n      clickEvent: \"clickEvent\",\n      doubleClickEvent: \"doubleClickEvent\",\n      mouseOverEvent: \"mouseOverEvent\",\n      mouseOutEvent: \"mouseOutEvent\",\n      onInitialize: \"onInitialize\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return SvgCircleDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Import Angular libraries.\n */\nlet SvgEllipseDirective = /*#__PURE__*/(() => {\n  class SvgEllipseDirective {\n    /**\n     * Create SVG Ellipse directive.\n     * @param _svgContainer - Host SVG Container Component object instance.\n     * @param _elRef - Angular element reference object instance.\n     */\n    constructor(_svgContainer, _elRef) {\n      this._svgContainer = _svgContainer;\n      this._elRef = _elRef;\n      this.color = '#000'; // Color of the ellipse background\n      this.x = 0; // Starting point on x axis.\n      this.y = 0; // Starting point on y axis.\n      this.classes = []; // List of CSS classes which needs to be added.\n      /**\n       * Output variables for the ellipse directive.\n       */\n      this.clickEvent = new EventEmitter();\n      this.doubleClickEvent = new EventEmitter();\n      this.mouseOverEvent = new EventEmitter();\n      this.mouseOutEvent = new EventEmitter();\n      this.onInitialize = new EventEmitter();\n    }\n    /**\n     * Creates or updates the ellipse object within the container\n     */\n    ngAfterViewChecked() {\n      // Check if container is created and no ellipse object is created\n      if (this._svgContainer.getContainer() && !this._ellipse) {\n        this.createEllipse();\n      }\n    }\n    /**\n     * Does all required pre-requisites before destroying the component.\n     */\n    ngOnDestroy() {\n      this._ellipse.remove();\n    }\n    /**\n     * Is called when changes are made to the ellipse object.\n     * @param changes - Angular Simple Changes object containing all of the changes.\n     */\n    ngOnChanges(changes) {\n      if (this._ellipse) {\n        // If we have already created the object, update it.\n        this.updateEllipse();\n        // Check if classes were changed\n        if (changes.classes && changes.classes.currentValue !== changes.classes.previousValue) {\n          // Get classes that needs to be removed\n          const classesToRemove = changes.classes.previousValue.filter(previousClass => !changes.classes.currentValue.some(currentClass => currentClass === previousClass));\n          // Get classes that needs to be added\n          const classesToAdd = changes.classes.currentValue.filter(currentClass => !changes.classes.previousValue.some(previousClass => currentClass === previousClass));\n          // Add and remove classes\n          this.addRemoveClasses(classesToAdd, classesToRemove);\n        }\n      }\n    }\n    /**\n     * Update ellipse object within the SVG container.\n     */\n    updateEllipse() {\n      this._ellipse.size(this.width, this.height) // Update the width and height\n      .fill(this.color) // Update the color\n      .attr('cx', +this.x + +this.width / 2) // Set x position\n      .attr('cy', +this.y + +this.height / 2); // Set y position\n      // Let's set element in a correct position\n      this.setCorrectPosition();\n    }\n    /**\n     * Create ellipse object within the SVG container.\n     */\n    createEllipse() {\n      this._ellipse = this._svgContainer.getContainer().ellipse(this.width, this.height) // Set height and width of the ellipse\n      .fill(this.color) // Set fill color\n      .attr('cx', +this.x + +this.width / 2) // Set x position\n      .attr('cy', +this.y + +this.height / 2) // Set y position\n      .on('click', evt => this.clickEvent.emit(evt)) // Assign click event\n      .on('dblclick', evt => this.doubleClickEvent.emit(evt)) // Assign double click event\n      .on('mouseover', evt => this.mouseOverEvent.emit(evt)) // Assign mouse over event\n      .on('mouseout', evt => this.mouseOutEvent.emit(evt)); // Assign mouse out event\n      // Let's set element in a correct position\n      this.setCorrectPosition();\n      // Add classes to the ellipse\n      this.addRemoveClasses(this.classes);\n      // Let's output the ellipse element\n      this.onInitialize.emit(this._ellipse);\n    }\n    /**\n     * Sets correct position for the element.\n     */\n    setCorrectPosition() {\n      // Find position of an element within the parent container\n      const position = Array.prototype.slice.call(this._elRef.nativeElement.parentElement.children).indexOf(this._elRef.nativeElement);\n      // Let's update and insert element in a correct position.\n      if (this._svgContainer.getContainer().get(position) && this._ellipse.position() !== position) {\n        this._ellipse.insertBefore(this._svgContainer.getContainer().get(position));\n      }\n    }\n    /**\n     * Adds classes to the ellipse object.\n     * @param classesToAdd - List of classes, which needs to be added.\n     * @param classesToRemove - List of classes, which needs to be removed.\n     */\n    addRemoveClasses(classesToAdd, classesToRemove = []) {\n      // First let's remove classes, that are not necessary anymore\n      for (const classToRemove of classesToRemove) {\n        this._ellipse.removeClass(classToRemove);\n      }\n      // Now let's add new classes\n      for (const classToAdd of classesToAdd) {\n        this._ellipse.addClass(classToAdd);\n      }\n    }\n  }\n  SvgEllipseDirective.ɵfac = function SvgEllipseDirective_Factory(t) {\n    return new (t || SvgEllipseDirective)(ɵngcc0.ɵɵdirectiveInject(SvgContainerComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n  SvgEllipseDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: SvgEllipseDirective,\n    selectors: [[\"svg-ellipse\"]],\n    inputs: {\n      color: \"color\",\n      x: \"x\",\n      y: \"y\",\n      classes: \"classes\",\n      height: \"height\",\n      width: \"width\"\n    },\n    outputs: {\n      clickEvent: \"clickEvent\",\n      doubleClickEvent: \"doubleClickEvent\",\n      mouseOverEvent: \"mouseOverEvent\",\n      mouseOutEvent: \"mouseOutEvent\",\n      onInitialize: \"onInitialize\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return SvgEllipseDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Import Angular libraries.\n */\nlet SvgLineDirective = /*#__PURE__*/(() => {\n  class SvgLineDirective {\n    /**\n     * Create SVG Line directive.\n     * @param _svgContainer - Host SVG Container Component object instance.\n     * @param _elRef - Angular element reference object instance.\n     */\n    constructor(_svgContainer, _elRef) {\n      this._svgContainer = _svgContainer;\n      this._elRef = _elRef;\n      this.borderColor = '#000'; // Color of the line.\n      this.x0 = 0; // Starting point on x axis.\n      this.y0 = 0; // Starting point on y axis.\n      this.x1 = 1; // Ending point on x axis.\n      this.y1 = 1; // Ending point on y axis.\n      this.classes = []; // List of CSS classes which needs to be added.\n      /**\n       * Output variables for the line directive.\n       */\n      this.clickEvent = new EventEmitter();\n      this.doubleClickEvent = new EventEmitter();\n      this.mouseOverEvent = new EventEmitter();\n      this.mouseOutEvent = new EventEmitter();\n      this.onInitialize = new EventEmitter();\n    }\n    /**\n     * Creates or updates the line object within the container.\n     */\n    ngAfterViewChecked() {\n      // Check if container is created and no line object is created\n      if (this._svgContainer.getContainer() && !this._line) {\n        this.createLine();\n      }\n    }\n    /**\n     * Does all required pre-requisites before destroying the component.\n     */\n    ngOnDestroy() {\n      this._line.remove();\n    }\n    /**\n     * Is called when changes are made to the line object.\n     * @param changes - Angular Simple Changes object containing all of the changes.\n     */\n    ngOnChanges(changes) {\n      if (this._line) {\n        // If we have already created the object, update it.\n        this.updateLine();\n        // Check if classes were changed\n        if (changes.classes && changes.classes.currentValue !== changes.classes.previousValue) {\n          // Get classes that needs to be removed\n          const classesToRemove = changes.classes.previousValue.filter(previousClass => !changes.classes.currentValue.some(currentClass => currentClass === previousClass));\n          // Get classes that needs to be added\n          const classesToAdd = changes.classes.currentValue.filter(currentClass => !changes.classes.previousValue.some(previousClass => currentClass === previousClass));\n          // Add and remove classes\n          this.addRemoveClasses(classesToAdd, classesToRemove);\n        }\n      }\n    }\n    /**\n     * Update line object within the SVG container.\n     */\n    updateLine() {\n      this._line.plot(this.x0, this.y0, this.x1, this.y1) // Create the line at specific position\n      .stroke({\n        color: this.borderColor,\n        width: this.borderSize\n      }); // Set the border for the line\n      // Let's set element in a correct position\n      this.setCorrectPosition();\n    }\n    /**\n     * Create line object within the SVG container.\n     */\n    createLine() {\n      this._line = this._svgContainer.getContainer().line(this.x0, this.y0, this.x1, this.y1) // Create the line at specific position\n      .stroke({\n        color: this.borderColor,\n        width: this.borderSize\n      }) // Set the border for the line\n      .on('click', evt => this.clickEvent.emit(evt)) // Assign click event\n      .on('dblclick', evt => this.doubleClickEvent.emit(evt)) // Assign double click event\n      .on('mouseover', evt => this.mouseOverEvent.emit(evt)) // Assign mouse over event\n      .on('mouseout', evt => this.mouseOutEvent.emit(evt)); // Assign mouse out event\n      // Let's set element in a correct position\n      this.setCorrectPosition();\n      // Add classes to the line\n      this.addRemoveClasses(this.classes);\n      // Let's output the line element\n      this.onInitialize.emit(this._line);\n    }\n    /**\n     * Sets correct position for the element.\n     */\n    setCorrectPosition() {\n      // Find position of an element within the parent container\n      const position = Array.prototype.slice.call(this._elRef.nativeElement.parentElement.children).indexOf(this._elRef.nativeElement);\n      // Let's update and insert element in a correct position.\n      if (this._svgContainer.getContainer().get(position) && this._line.position() !== position) {\n        this._line.insertBefore(this._svgContainer.getContainer().get(position));\n      }\n    }\n    /**\n     * Adds classes to the line object.\n     * @param classesToAdd - List of classes, which needs to be added.\n     * @param classesToRemove - List of classes, which needs to be removed.\n     */\n    addRemoveClasses(classesToAdd, classesToRemove = []) {\n      // First let's remove classes, that are not necessary anymore\n      for (const classToRemove of classesToRemove) {\n        this._line.removeClass(classToRemove);\n      }\n      // Now let's add new classes\n      for (const classToAdd of classesToAdd) {\n        this._line.addClass(classToAdd);\n      }\n    }\n  }\n  SvgLineDirective.ɵfac = function SvgLineDirective_Factory(t) {\n    return new (t || SvgLineDirective)(ɵngcc0.ɵɵdirectiveInject(SvgContainerComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n  SvgLineDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: SvgLineDirective,\n    selectors: [[\"svg-line\"]],\n    inputs: {\n      borderColor: \"borderColor\",\n      x0: \"x0\",\n      y0: \"y0\",\n      x1: \"x1\",\n      y1: \"y1\",\n      classes: \"classes\",\n      borderSize: \"borderSize\"\n    },\n    outputs: {\n      clickEvent: \"clickEvent\",\n      doubleClickEvent: \"doubleClickEvent\",\n      mouseOverEvent: \"mouseOverEvent\",\n      mouseOutEvent: \"mouseOutEvent\",\n      onInitialize: \"onInitialize\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return SvgLineDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Import Angular libraries.\n */\nlet SvgPolylineDirective = /*#__PURE__*/(() => {\n  class SvgPolylineDirective {\n    /**\n     * Create SVG Polyline directive.\n     * @param _svgContainer - Host SVG Container Component object instance.\n     * @param _elRef - Angular element reference object instance.\n     */\n    constructor(_svgContainer, _elRef) {\n      this._svgContainer = _svgContainer;\n      this._elRef = _elRef;\n      this.borderColor = '#000'; // Color of the polyline.\n      this.fill = '#000'; // Color of the polyline body\n      this.classes = []; // List of CSS classes which needs to be added.\n      /**\n       * Output variables for the polyline directive.\n       */\n      this.clickEvent = new EventEmitter();\n      this.doubleClickEvent = new EventEmitter();\n      this.mouseOverEvent = new EventEmitter();\n      this.mouseOutEvent = new EventEmitter();\n      this.onInitialize = new EventEmitter();\n    }\n    /**\n     * Creates or updates the polyline object within the container.\n     */\n    ngAfterViewChecked() {\n      // Check if container is created and no polyline object is created\n      if (this._svgContainer.getContainer() && !this._polyline) {\n        this.createPolyline();\n      }\n    }\n    /**\n     * Does all required pre-requisites before destroying the component.\n     */\n    ngOnDestroy() {\n      this._polyline.remove();\n    }\n    /**\n     * Is called when changes are made to the polyline object.\n     * @param changes - Angular Simple Changes object containing all of the changes.\n     */\n    ngOnChanges(changes) {\n      if (this._polyline) {\n        // If we have already created the object, update it.\n        this.updatePolyline();\n        // Check if classes were changed\n        if (changes.classes && changes.classes.currentValue !== changes.classes.previousValue) {\n          // Get classes that needs to be removed\n          const classesToRemove = changes.classes.previousValue.filter(previousClass => !changes.classes.currentValue.some(currentClass => currentClass === previousClass));\n          // Get classes that needs to be added\n          const classesToAdd = changes.classes.currentValue.filter(currentClass => !changes.classes.previousValue.some(previousClass => currentClass === previousClass));\n          // Add and remove classes\n          this.addRemoveClasses(classesToAdd, classesToRemove);\n        }\n      }\n    }\n    /**\n     * Update polyline object within the SVG container.\n     */\n    updatePolyline() {\n      this._polyline.plot(this.points) // Update the polyline object\n      .fill(this.fill) // Fill color of the polyline\n      .stroke({\n        color: this.borderColor,\n        width: this.borderSize\n      }); // Set the border for the polyline\n      // Let's set element in a correct position\n      this.setCorrectPosition();\n    }\n    /**\n     * Create polyline object within the SVG container.\n     */\n    createPolyline() {\n      this._polyline = this._svgContainer.getContainer().polyline(this.points) // Create the polyline object\n      .fill(this.fill) // Fill color of the polyline\n      .stroke({\n        color: this.borderColor,\n        width: this.borderSize\n      }) // Set the border for the polyline\n      .on('click', evt => this.clickEvent.emit(evt)) // Assign click event\n      .on('dblclick', evt => this.doubleClickEvent.emit(evt)) // Assign double click event\n      .on('mouseover', evt => this.mouseOverEvent.emit(evt)) // Assign mouse over event\n      .on('mouseout', evt => this.mouseOutEvent.emit(evt)); // Assign mouse out event\n      // Let's set element in a correct position\n      this.setCorrectPosition();\n      // Add classes to the polyline\n      this.addRemoveClasses(this.classes);\n      // Let's output the polyline element\n      this.onInitialize.emit(this._polyline);\n    }\n    /**\n     * Sets correct position for the element.\n     */\n    setCorrectPosition() {\n      // Find position of an element within the parent container\n      const position = Array.prototype.slice.call(this._elRef.nativeElement.parentElement.children).indexOf(this._elRef.nativeElement);\n      // Let's update and insert element in a correct position.\n      if (this._svgContainer.getContainer().get(position) && this._polyline.position() !== position) {\n        this._polyline.insertBefore(this._svgContainer.getContainer().get(position));\n      }\n    }\n    /**\n     * Adds classes to the polyline object.\n     * @param classesToAdd - List of classes, which needs to be added.\n     * @param classesToRemove - List of classes, which needs to be removed.\n     */\n    addRemoveClasses(classesToAdd, classesToRemove = []) {\n      // First let's remove classes, that are not necessary anymore\n      for (const classToRemove of classesToRemove) {\n        this._polyline.removeClass(classToRemove);\n      }\n      // Now let's add new classes\n      for (const classToAdd of classesToAdd) {\n        this._polyline.addClass(classToAdd);\n      }\n    }\n  }\n  SvgPolylineDirective.ɵfac = function SvgPolylineDirective_Factory(t) {\n    return new (t || SvgPolylineDirective)(ɵngcc0.ɵɵdirectiveInject(SvgContainerComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n  SvgPolylineDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: SvgPolylineDirective,\n    selectors: [[\"svg-polyline\"]],\n    inputs: {\n      borderColor: \"borderColor\",\n      fill: \"fill\",\n      classes: \"classes\",\n      points: \"points\",\n      borderSize: \"borderSize\"\n    },\n    outputs: {\n      clickEvent: \"clickEvent\",\n      doubleClickEvent: \"doubleClickEvent\",\n      mouseOverEvent: \"mouseOverEvent\",\n      mouseOutEvent: \"mouseOutEvent\",\n      onInitialize: \"onInitialize\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return SvgPolylineDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Import Angular libraries.\n */\nlet SvgPolygonDirective = /*#__PURE__*/(() => {\n  class SvgPolygonDirective {\n    /**\n     * Create SVG Polygon directive.\n     * @param _svgContainer - Host SVG Container Component object instance.\n     * @param _elRef - Angular element reference object instance.\n     */\n    constructor(_svgContainer, _elRef) {\n      this._svgContainer = _svgContainer;\n      this._elRef = _elRef;\n      this.borderColor = '#000'; // Color of the polygon.\n      this.fill = '#000'; // Color of the polygon body.\n      this.classes = []; // List of CSS classes which needs to be added.\n      /**\n       * Output variables for the polygon directive.\n       */\n      this.clickEvent = new EventEmitter();\n      this.doubleClickEvent = new EventEmitter();\n      this.mouseOverEvent = new EventEmitter();\n      this.mouseOutEvent = new EventEmitter();\n      this.onInitialize = new EventEmitter();\n    }\n    /**\n     * Creates or updates the polygon object within the container.\n     */\n    ngAfterViewChecked() {\n      // Check if container is created and no polygon object is created\n      if (this._svgContainer.getContainer() && !this._polygon) {\n        this.createPolygon();\n      }\n    }\n    /**\n     * Does all required pre-requisites before destroying the component.\n     */\n    ngOnDestroy() {\n      this._polygon.remove();\n    }\n    /**\n     * Is called when changes are made to the polygon object.\n     * @param changes - Angular Simple Changes object containing all of the changes.\n     */\n    ngOnChanges(changes) {\n      if (this._polygon) {\n        // If we have already created the object, update it.\n        this.updatePolygon();\n        // Check if classes were changed\n        if (changes.classes && changes.classes.currentValue !== changes.classes.previousValue) {\n          // Get classes that needs to be removed\n          const classesToRemove = changes.classes.previousValue.filter(previousClass => !changes.classes.currentValue.some(currentClass => currentClass === previousClass));\n          // Get classes that needs to be added\n          const classesToAdd = changes.classes.currentValue.filter(currentClass => !changes.classes.previousValue.some(previousClass => currentClass === previousClass));\n          // Add and remove classes\n          this.addRemoveClasses(classesToAdd, classesToRemove);\n        }\n      }\n    }\n    /**\n     * Update polygon object within the SVG container.\n     */\n    updatePolygon() {\n      this._polygon.plot(this.points) // Update the polygon object\n      .fill(this.fill) // Fill color of the polygon\n      .stroke({\n        color: this.borderColor,\n        width: this.borderSize\n      }); // Set the border for the polygon\n      // Let's set element in a correct position\n      this.setCorrectPosition();\n    }\n    /**\n     * Create polygon object within the SVG container.\n     */\n    createPolygon() {\n      this._polygon = this._svgContainer.getContainer().polygon(this.points) // Create the polygon object\n      .fill(this.fill) // Fill color of the polygon\n      .stroke({\n        color: this.borderColor,\n        width: this.borderSize\n      }) // Set the border for the polygon\n      .on('click', evt => this.clickEvent.emit(evt)) // Assign click event\n      .on('dblclick', evt => this.doubleClickEvent.emit(evt)) // Assign double click event\n      .on('mouseover', evt => this.mouseOverEvent.emit(evt)) // Assign mouse over event\n      .on('mouseout', evt => this.mouseOutEvent.emit(evt)); // Assign mouse out event\n      // Let's set element in a correct position\n      this.setCorrectPosition();\n      // Add classes to the polygon\n      this.addRemoveClasses(this.classes);\n      // Let's output the polygon element\n      this.onInitialize.emit(this._polygon);\n    }\n    /**\n     * Sets correct position for the element.\n     */\n    setCorrectPosition() {\n      // Find position of an element within the parent container\n      const position = Array.prototype.slice.call(this._elRef.nativeElement.parentElement.children).indexOf(this._elRef.nativeElement);\n      // Let's update and insert element in a correct position.\n      if (this._svgContainer.getContainer().get(position) && this._polygon.position() !== position) {\n        this._polygon.insertBefore(this._svgContainer.getContainer().get(position));\n      }\n    }\n    /**\n     * Adds classes to the polygon object.\n     * @param classesToAdd - List of classes, which needs to be added.\n     * @param classesToRemove - List of classes, which needs to be removed.\n     */\n    addRemoveClasses(classesToAdd, classesToRemove = []) {\n      // First let's remove classes, that are not necessary anymore\n      for (const classToRemove of classesToRemove) {\n        this._polygon.removeClass(classToRemove);\n      }\n      // Now let's add new classes\n      for (const classToAdd of classesToAdd) {\n        this._polygon.addClass(classToAdd);\n      }\n    }\n  }\n  SvgPolygonDirective.ɵfac = function SvgPolygonDirective_Factory(t) {\n    return new (t || SvgPolygonDirective)(ɵngcc0.ɵɵdirectiveInject(SvgContainerComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n  SvgPolygonDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: SvgPolygonDirective,\n    selectors: [[\"svg-polygon\"]],\n    inputs: {\n      borderColor: \"borderColor\",\n      fill: \"fill\",\n      classes: \"classes\",\n      points: \"points\",\n      borderSize: \"borderSize\"\n    },\n    outputs: {\n      clickEvent: \"clickEvent\",\n      doubleClickEvent: \"doubleClickEvent\",\n      mouseOverEvent: \"mouseOverEvent\",\n      mouseOutEvent: \"mouseOutEvent\",\n      onInitialize: \"onInitialize\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return SvgPolygonDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Import Angular libraries.\n */\nlet SvgImageDirective = /*#__PURE__*/(() => {\n  class SvgImageDirective {\n    /**\n     * Create SVG image directive.\n     * @param _svgContainer - Host SVG Container Component object instance.\n     * @param _elRef - Angular element reference object instance.\n     */\n    constructor(_svgContainer, _elRef) {\n      this._svgContainer = _svgContainer;\n      this._elRef = _elRef;\n      this.x = 0; // Starting point on x axis.\n      this.y = 0; // Starting point on y axis.\n      this.height = 100; // Height of the image.\n      this.width = 100; // Width of the image.\n      this.classes = []; // List of CSS classes which needs to be added.\n      /**\n       * Output variables for the image directive.\n       */\n      this.clickEvent = new EventEmitter();\n      this.doubleClickEvent = new EventEmitter();\n      this.mouseOverEvent = new EventEmitter();\n      this.mouseOutEvent = new EventEmitter();\n      this.onInitialize = new EventEmitter();\n    }\n    /**\n     * Creates the image object within the container.\n     */\n    ngAfterViewChecked() {\n      // Check if container is created and no image object is created\n      if (this._svgContainer.getContainer() && !this._image) {\n        this.createImage();\n      }\n    }\n    /**\n     * Does all required pre-requisites before destroying the component.\n     */\n    ngOnDestroy() {\n      this._image.remove();\n    }\n    /**\n     * Is called when changes are made to the image object.\n     * @param changes - Angular Simple Changes object containing all of the changes.\n     */\n    ngOnChanges(changes) {\n      // Make sure we check it only when image is initialized\n      if (this._image) {\n        // Update image also in case image url has changed\n        if (changes.imageUrl && changes.imageUrl.currentValue !== changes.imageUrl.previousValue) {\n          // Update image properties and image itself\n          this.updateImage(true);\n        } else if (changes.x && changes.x.currentValue !== changes.x.previousValue || changes.y && changes.y.currentValue !== changes.y.previousValue || changes.width && changes.width.currentValue !== changes.width.previousValue || changes.height && changes.height.currentValue !== changes.height.previousValue) {\n          // Update only image properties\n          this.updateImage(false);\n        }\n        // Check if classes were changed\n        if (changes.classes && changes.classes.currentValue !== changes.classes.previousValue) {\n          // Get classes that needs to be removed\n          const classesToRemove = changes.classes.previousValue.filter(previousClass => !changes.classes.currentValue.some(currentClass => currentClass === previousClass));\n          // Get classes that needs to be added\n          const classesToAdd = changes.classes.currentValue.filter(currentClass => !changes.classes.previousValue.some(previousClass => currentClass === previousClass));\n          // Add and remove classes\n          this.addRemoveClasses(classesToAdd, classesToRemove);\n        }\n      }\n    }\n    /**\n     * Update image object within the SVG container.\n     * @param reloadImage - Boolean indicator if image should be reloaded.\n     */\n    updateImage(reloadImage) {\n      // Check if we have to update only image properties, or also image itself\n      if (reloadImage) {\n        this._image.load(this.imageUrl) // Update image\n        .size(this.width, this.height) // Update image size\n        .move(this.x, this.y); // Update image position\n      } else {\n        // Update just image properties\n        this._image.size(this.width, this.height) // Update image size\n        .move(this.x, this.y); // Update image position\n      }\n      // Let's set element in a correct position\n      this.setCorrectPosition();\n    }\n    /**\n     * Create image object within the SVG container.\n     */\n    createImage() {\n      this._image = this._svgContainer.getContainer().image() // Assign image object\n      .load(this.imageUrl) // Load image\n      .size(this.width, this.height) // Assign image size\n      .move(this.x, this.y) // Assign position\n      .on('click', evt => this.clickEvent.emit(evt)) // Assign click event\n      .on('dblclick', evt => this.doubleClickEvent.emit(evt)) // Assign double click event\n      .on('mouseover', evt => this.mouseOverEvent.emit(evt)) // Assign mouse over event\n      .on('mouseout', evt => this.mouseOutEvent.emit(evt)); // Assign mouse out event\n      // Let's set element in a correct position\n      this.setCorrectPosition();\n      // Add classes to the image\n      this.addRemoveClasses(this.classes);\n      // Let's output the image element\n      this.onInitialize.emit(this._image);\n    }\n    /**\n     * Sets correct position for the element.\n     */\n    setCorrectPosition() {\n      // Find position of an element within the parent container\n      const position = Array.prototype.slice.call(this._elRef.nativeElement.parentElement.children).indexOf(this._elRef.nativeElement);\n      // Let's update and insert element in a correct position.\n      if (this._svgContainer.getContainer().get(position) && this._image.position() !== position) {\n        this._image.insertBefore(this._svgContainer.getContainer().get(position));\n      }\n    }\n    /**\n     * Adds classes to the image object.\n     * @param classesToAdd - List of classes, which needs to be added.\n     * @param classesToRemove - List of classes, which needs to be removed.\n     */\n    addRemoveClasses(classesToAdd, classesToRemove = []) {\n      // First let's remove classes, that are not necessary anymore\n      for (const classToRemove of classesToRemove) {\n        this._image.removeClass(classToRemove);\n      }\n      // Now let's add new classes\n      for (const classToAdd of classesToAdd) {\n        this._image.addClass(classToAdd);\n      }\n    }\n  }\n  SvgImageDirective.ɵfac = function SvgImageDirective_Factory(t) {\n    return new (t || SvgImageDirective)(ɵngcc0.ɵɵdirectiveInject(SvgContainerComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n  SvgImageDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: SvgImageDirective,\n    selectors: [[\"svg-image\"]],\n    inputs: {\n      x: \"x\",\n      y: \"y\",\n      height: \"height\",\n      width: \"width\",\n      classes: \"classes\",\n      imageUrl: \"imageUrl\"\n    },\n    outputs: {\n      clickEvent: \"clickEvent\",\n      doubleClickEvent: \"doubleClickEvent\",\n      mouseOverEvent: \"mouseOverEvent\",\n      mouseOutEvent: \"mouseOutEvent\",\n      onInitialize: \"onInitialize\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return SvgImageDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Import Angular libraries.\n */\nlet SvgPathDirective = /*#__PURE__*/(() => {\n  class SvgPathDirective {\n    /**\n     * Create SVG Path directive.\n     * @param _svgContainer - Host SVG Container Component object instance.\n     * @param _elRef - Angular element reference object instance.\n     */\n    constructor(_svgContainer, _elRef) {\n      this._svgContainer = _svgContainer;\n      this._elRef = _elRef;\n      /**\n       * Import variables for the path directive.\n       */\n      this.path = ''; // Path which needs to be displayed.\n      this.borderColor = '#000'; // Color of the border.\n      this.borderSize = 2; // Size of the border.\n      this.x = 0; // Starting point on x axis.\n      this.y = 0; // Starting point on y axis.\n      this.fill = ''; // Fill color of the path.\n      this.classes = []; // List of CSS classes which needs to be added.\n      /**\n       * Output variables for the path directive.\n       */\n      this.clickEvent = new EventEmitter();\n      this.doubleClickEvent = new EventEmitter();\n      this.mouseOverEvent = new EventEmitter();\n      this.mouseOutEvent = new EventEmitter();\n      this.onInitialize = new EventEmitter();\n    }\n    /**\n     * Creates the path object within the container.\n     */\n    ngAfterViewChecked() {\n      // Check if container is created and no path object is created\n      if (this._svgContainer.getContainer() && !this._path) {\n        this.createPath();\n      }\n    }\n    /**\n     * Does all required pre-requisites before destroying the component.\n     */\n    ngOnDestroy() {\n      this._path.remove();\n    }\n    /**\n     * Is called when changes are made to the path object.\n     * @param changes - Angular Simple Changes object containing all of the changes.\n     */\n    ngOnChanges(changes) {\n      if (this._path) {\n        // If we have already created the object, update it.\n        this.updatePath();\n        // Check if classes were changed\n        if (changes.classes && changes.classes.currentValue !== changes.classes.previousValue) {\n          // Get classes that needs to be removed\n          const classesToRemove = changes.classes.previousValue.filter(previousClass => !changes.classes.currentValue.some(currentClass => currentClass === previousClass));\n          // Get classes that needs to be added\n          const classesToAdd = changes.classes.currentValue.filter(currentClass => !changes.classes.previousValue.some(previousClass => currentClass === previousClass));\n          // Add and remove classes\n          this.addRemoveClasses(classesToAdd, classesToRemove);\n        }\n      }\n    }\n    /**\n     * Update path object within the SVG container.\n     */\n    updatePath() {\n      this._path.plot(this.path) // Update the path for the element\n      .stroke({\n        color: this.borderColor,\n        width: this.borderSize\n      }) // Update the border for the\n      .fill(this.fill || 'rgba(0, 0, 0, 0)') // Update fill of the path\n      .move(this.x, this.y); // Update the location of the path\n      // Let's set element in a correct position\n      this.setCorrectPosition();\n    }\n    /**\n     * Create path object within the SVG container.\n     */\n    createPath() {\n      this._path = this._svgContainer.getContainer().path(this.path) // Set the path for the element\n      .stroke({\n        color: this.borderColor,\n        width: this.borderSize\n      }) // Set the border for the path\n      .fill(this.fill || 'rgba(0, 0, 0, 0)') // Set fill of the path\n      .move(this.x, this.y) // Set the location of the path\n      .on('click', evt => this.clickEvent.emit(evt)) // Assign click event\n      .on('dblclick', evt => this.doubleClickEvent.emit(evt)) // Assign double click event\n      .on('mouseover', evt => this.mouseOverEvent.emit(evt)) // Assign mouse over event\n      .on('mouseout', evt => this.mouseOutEvent.emit(evt)); // Assign mouse out event\n      // Let's set element in a correct position\n      this.setCorrectPosition();\n      // Add classes to the path\n      this.addRemoveClasses(this.classes);\n      // Let's output the path element\n      this.onInitialize.emit(this._path);\n    }\n    /**\n     * Sets correct position for the element.\n     */\n    setCorrectPosition() {\n      // Find position of an element within the parent container\n      const position = Array.prototype.slice.call(this._elRef.nativeElement.parentElement.children).indexOf(this._elRef.nativeElement);\n      // Let's update and insert element in a correct position.\n      if (this._svgContainer.getContainer().get(position) && this._path.position() !== position) {\n        this._path.insertBefore(this._svgContainer.getContainer().get(position));\n      }\n    }\n    /**\n     * Adds classes to the path object.\n     * @param classesToAdd - List of classes, which needs to be added.\n     * @param classesToRemove - List of classes, which needs to be removed.\n     */\n    addRemoveClasses(classesToAdd, classesToRemove = []) {\n      // First let's remove classes, that are not necessary anymore\n      for (const classToRemove of classesToRemove) {\n        this._path.removeClass(classToRemove);\n      }\n      // Now let's add new classes\n      for (const classToAdd of classesToAdd) {\n        this._path.addClass(classToAdd);\n      }\n    }\n  }\n  SvgPathDirective.ɵfac = function SvgPathDirective_Factory(t) {\n    return new (t || SvgPathDirective)(ɵngcc0.ɵɵdirectiveInject(SvgContainerComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n  SvgPathDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: SvgPathDirective,\n    selectors: [[\"svg-path\"]],\n    inputs: {\n      path: \"path\",\n      borderColor: \"borderColor\",\n      borderSize: \"borderSize\",\n      x: \"x\",\n      y: \"y\",\n      fill: \"fill\",\n      classes: \"classes\"\n    },\n    outputs: {\n      clickEvent: \"clickEvent\",\n      doubleClickEvent: \"doubleClickEvent\",\n      mouseOverEvent: \"mouseOverEvent\",\n      mouseOutEvent: \"mouseOutEvent\",\n      onInitialize: \"onInitialize\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return SvgPathDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Import Angular libraries.\n */\nlet SvgTextDirective = /*#__PURE__*/(() => {\n  class SvgTextDirective {\n    /**\n     * Create SVG Text directive.\n     * @param _svgContainer - Host SVG Container Component object instance.\n     * @param _elRef - Angular element reference object instance.\n     */\n    constructor(_svgContainer, _elRef) {\n      this._svgContainer = _svgContainer;\n      this._elRef = _elRef;\n      /**\n       * Import variables for the text directive.\n       */\n      this.color = '#000'; // Color of the text.\n      this.text = ''; // Text which needs to be displayed.\n      this.x = 0; // Starting point on x axis.\n      this.y = 0; // Starting point on y axis.\n      this.size = 10; // Size of the text.\n      this.classes = []; // List of CSS classes which needs to be added.\n      /**\n       * Output variables for the text directive.\n       */\n      this.clickEvent = new EventEmitter();\n      this.doubleClickEvent = new EventEmitter();\n      this.mouseOverEvent = new EventEmitter();\n      this.mouseOutEvent = new EventEmitter();\n      this.onInitialize = new EventEmitter();\n    }\n    /**\n     * Creates the text object within the container.\n     */\n    ngAfterViewChecked() {\n      // Check if container is created and no text object is created\n      if (this._svgContainer.getContainer() && !this._text) {\n        this.createText();\n      }\n    }\n    /**\n     * Does all required pre-requisites before destroying the component.\n     */\n    ngOnDestroy() {\n      this._text.remove();\n    }\n    /**\n     * Is called when changes are made to the text object.\n     * @param changes - Angular Simple Changes object containing all of the changes.\n     */\n    ngOnChanges(changes) {\n      if (this._text) {\n        // If we have already created the object, update it.\n        this.updateText();\n        // Check if classes were changed\n        if (changes.classes && changes.classes.currentValue !== changes.classes.previousValue) {\n          // Get classes that needs to be removed\n          const classesToRemove = changes.classes.previousValue.filter(previousClass => !changes.classes.currentValue.some(currentClass => currentClass === previousClass));\n          // Get classes that needs to be added\n          const classesToAdd = changes.classes.currentValue.filter(currentClass => !changes.classes.previousValue.some(previousClass => currentClass === previousClass));\n          // Add and remove classes\n          this.addRemoveClasses(classesToAdd, classesToRemove);\n        }\n      }\n    }\n    /**\n     * Update text object within the SVG container.\n     */\n    updateText() {\n      this._text.text(this.text) // Update the text for the element\n      .fill(this.color) // Update the color of the text\n      .font({\n        size: this.size // Update the size of the text\n      }).move(this.x, this.y); // Update the location of the text\n      // Let's set element in a correct position\n      this.setCorrectPosition();\n    }\n    /**\n     * Create text object within the SVG container.\n     */\n    createText() {\n      this._text = this._svgContainer.getContainer().text(this.text) // Set the text for the element\n      .fill(this.color) // Set the color of the text\n      .font({\n        size: this.size // Set the size of the text\n      }).move(this.x, this.y) // Set the location of the text\n      .on('click', evt => this.clickEvent.emit(evt)) // Assign click event\n      .on('dblclick', evt => this.doubleClickEvent.emit(evt)) // Assign double click event\n      .on('mouseover', evt => this.mouseOverEvent.emit(evt)) // Assign mouse over event\n      .on('mouseout', evt => this.mouseOutEvent.emit(evt)); // Assign mouse out event\n      // Let's set element in a correct position\n      this.setCorrectPosition();\n      // Add classes to the text\n      this.addRemoveClasses(this.classes);\n      // Let's output the text element\n      this.onInitialize.emit(this._text);\n    }\n    /**\n     * Sets correct position for the element.\n     */\n    setCorrectPosition() {\n      // Find position of an element within the parent container\n      const position = Array.prototype.slice.call(this._elRef.nativeElement.parentElement.children).indexOf(this._elRef.nativeElement);\n      // Let's update and insert element in a correct position.\n      if (this._svgContainer.getContainer().get(position) && this._text.position() !== position) {\n        this._text.insertBefore(this._svgContainer.getContainer().get(position));\n      }\n    }\n    /**\n     * Adds classes to the text object.\n     * @param classesToAdd - List of classes, which needs to be added.\n     * @param classesToRemove - List of classes, which needs to be removed.\n     */\n    addRemoveClasses(classesToAdd, classesToRemove = []) {\n      // First let's remove classes, that are not necessary anymore\n      for (const classToRemove of classesToRemove) {\n        this._text.removeClass(classToRemove);\n      }\n      // Now let's add new classes\n      for (const classToAdd of classesToAdd) {\n        this._text.addClass(classToAdd);\n      }\n    }\n  }\n  SvgTextDirective.ɵfac = function SvgTextDirective_Factory(t) {\n    return new (t || SvgTextDirective)(ɵngcc0.ɵɵdirectiveInject(SvgContainerComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n  SvgTextDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: SvgTextDirective,\n    selectors: [[\"svg-text\"]],\n    inputs: {\n      color: \"color\",\n      text: \"text\",\n      x: \"x\",\n      y: \"y\",\n      size: \"size\",\n      classes: \"classes\"\n    },\n    outputs: {\n      clickEvent: \"clickEvent\",\n      doubleClickEvent: \"doubleClickEvent\",\n      mouseOverEvent: \"mouseOverEvent\",\n      mouseOutEvent: \"mouseOutEvent\",\n      onInitialize: \"onInitialize\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return SvgTextDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Import Angular Libraries.\n */\nlet NgxSvgModule = /*#__PURE__*/(() => {\n  class NgxSvgModule {}\n  NgxSvgModule.ɵfac = function NgxSvgModule_Factory(t) {\n    return new (t || NgxSvgModule)();\n  };\n  NgxSvgModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NgxSvgModule\n  });\n  NgxSvgModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return NgxSvgModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxSvgModule, {\n    declarations: function () {\n      return [SvgContainerComponent, SvgRectDirective, SvgCircleDirective, SvgEllipseDirective, SvgLineDirective, SvgPolylineDirective, SvgPolygonDirective, SvgImageDirective, SvgPathDirective, SvgTextDirective];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [SvgContainerComponent, SvgRectDirective, SvgCircleDirective, SvgEllipseDirective, SvgLineDirective, SvgPolylineDirective, SvgPolygonDirective, SvgImageDirective, SvgPathDirective, SvgTextDirective];\n    }\n  });\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NgxSvgModule, SvgContainerComponent as ɵa, SvgRectDirective as ɵb, SvgCircleDirective as ɵc, SvgEllipseDirective as ɵd, SvgLineDirective as ɵe, SvgPolylineDirective as ɵf, SvgPolygonDirective as ɵg, SvgImageDirective as ɵh, SvgPathDirective as ɵi, SvgTextDirective as ɵj };\n\n//# sourceMappingURL=ngx-svg.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}